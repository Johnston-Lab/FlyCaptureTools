#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script analyses frame timestamps from csv files. Can have one or multiple
cameras. Calcultes and plots frame durations, and synchrony between cameras
(if there are multiple cameras).

Commandline flags
-----------------
-i, --input
    Path(s) to input timestamp CSV file(s). These can either contain the
    timestamps from the image metadata (generated by the video writer) or from
    embedded image info (generated by extract_embedded_image_info.py script).
    May specify multiple files to the flag to input multiple cameras together
    (but they should all refer to the same recording). If there are also
    multiple recordings, the flag can be specified multiple times (once per
    recording).

-o, --output-excel
    Path to output Excel file. Will save timestamps + frame durations, and
    synchrony values between cameras (if multiple cameras are included).
    Also serves as basename for output plot files. A .xlsx extension will be
    appended if one isn't included. If there are multiple recordings, the flag
    can be specified multiple times to give a separate output file for each
    recording.

Example usage
-------------
# Process timestamps for a single recording from a single camera
> python analyse_timestamps.py -i clip0_cam0.csv -o clip0_single.xlsx

# Process timestamps for a single recording from multiple cameras
> python analyse_timestamps.py \\
      -i clip0_cam0.csv clip0_cam1.csv clip0_cam2.csv -o clip0_multi.xlsx

# Process timestamps for multiple recordings from multiple cameras
> python analyse_timestamps.py \\
      -i clip0_cam0.csv clip0_cam1.csv clip0_cam2.csv -o clip0_multi.xlsx \\
      -i clip1_cam0.csv clip1_cam1.csv clip1_cam2.csv -o clip1_multi.xlsx

# If there are lots of files, we can save on typing with wildcard expansion.
# This is platform specific. The following should work for Windows Powershell:
> python analyse_timestamps.py \\
    -i (Get-ChildItem clip0_cam*.csv) -o clip0_multi.xlsx \\
    -i (Get-ChildItem clip1_cam*.csv) -o clip1_multi.xlsx
"""

import os
import re
import argparse
import warnings
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# matplotlib colour cycle
COLORS = plt.rcParams['axes.prop_cycle'].by_key()['color']


### Custom funcs
class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter,
                      argparse.RawTextHelpFormatter):
    """
    Combines argparse formatters
    """
    pass

def cycles2timestamps(df, inplace=False):
    """
    Calculate timestamps (in seconds) from cycle cols
    """
    # Extract cycle timing. Col names will differ depending on whether
    # timestamps are from metadata or embedded pixel info
    if 'cycleSeconds' in df.columns:  # from metadata
        cycleSecs = df['cycleSeconds'].copy()
        cycleCount = df['cycleCount'].copy()
        cycleOffset = df['cycleOffset'].copy()
    elif 'timestamp.second_count' in df.columns:  # from embedded info
        cycleSecs = df['timestamp.second_count'].copy()
        cycleCount = df['timestamp.cycle_count'].copy()
        cycleOffset = df['timestamp.cycle_offset'].copy()
    else:
        raise RuntimeError('Can\'t find timestamps in dataframe')

    # "Unwrap" cycle seconds by adding 128 at every wrap-around
    for i in range(1, len(cycleSecs)):
        t0 = cycleSecs[i-1]
        t1 = cycleSecs[i]
        if t1 < t0:
            cycleSecs[i:] += 128

    # Convert cycle counts & offset to secs, add to secs
    countSecs = (cycleCount + cycleOffset / 3072) / 8000
    cycleSecs += countSecs

    # Append to dataset or return
    if inplace:
        df['timestamp'] = cycleSecs
    else:
        return cycleSecs


### Begin ###

# Parse args
parser = argparse.ArgumentParser(usage=__doc__,
                                 formatter_class=CustomFormatter)

parser.add_argument('-i', '--input', nargs='+', action='append', required=True,
                    help='Path(s) to input file(s). Specify once per recording.')
parser.add_argument('-o', '--output-excel', action='append', required=True,
                    help='Path to output excel file. Specify once per recording.')

args = parser.parse_args()
infiles = args.input
out_xlfiles = args.output_excel

if len(infiles) != len(out_xlfiles):
    raise OSError('Input and output flags must be specified same number of times')

# Loop file groups
for i, (infile_group, out_xlfile) in enumerate(zip(infiles, out_xlfiles)):
    print(f'Group {i}: {infile_group}')

    ## Load data ##
    # Check outfile
    ext = os.path.splitext(out_xlfile)[1]
    if not ext:
        out_xlfile += '.xlsx'
    elif ext != '.xlsx':
        warnings.warn('Changing output file extension to .xlsx')
        out_xlfile = out_xlfile.replace(ext, '.xlsx')

    # Load data
    nCams = len(infile_group)
    all_df = {}
    for j, infile in enumerate(sorted(infile_group)):
        print(f'\tFile {j}: {infile}')
        # Load csv
        cam_df = pd.read_csv(infile)

        # Append timestamps
        cycles2timestamps(cam_df, inplace=True)

        # Calculate & append frame durations
        cam_df['framedur'] = cam_df['timestamp'].diff()

        # Try to work out camera ID from filename (should work for
        # ones made by multicam runner script), or otherwise just use
        # position in list
        try:
            camID = re.findall('cam[0-9]+', infile)[0]
        except:
            camID = str(j)

        # camID needs to be unique!
        if camID in all_df.keys():
            raise Exception(f'Camera "{camID}" is duplicated')

        # Append to data
        all_df[camID] = cam_df

    # Multi-cam only: calculate synchrony
    if nCams > 1:
        max_frameN = max(len(cam_df) for cam_df in all_df.values())
        wide_timestamps = np.full([max_frameN, nCams], np.nan)
        for j, cam_df in enumerate(all_df.values()):
            wide_timestamps[:len(cam_df), j] = cam_df['timestamp']

        synchrony = wide_timestamps - np.nanmean(wide_timestamps, axis=1)[:,None]
        synchrony = pd.DataFrame(synchrony, columns=all_df.keys())


    ## Save to excel ##
    print('\tSaving...')
    writer = pd.ExcelWriter(out_xlfile)

    for camID, cam_df in all_df.items():
        cam_df.to_excel(writer, sheet_name=camID, index=False)

    if nCams > 1:
        synchrony.to_excel(writer, sheet_name='synchrony', index=False)

    writer.close()


    ## Plots ##
    print('\tPlotting...')

    # Line plots and histograms of frame durs #
    fig, axes = plt.subplots(nrows=2, ncols=nCams, figsize=(3*nCams, 7),
                             sharey='row', sharex='row', squeeze=False,
                             gridspec_kw={'hspace':0.3})

    for j, (camID, cam_df) in enumerate(all_df.items()):
        color = COLORS[j % len(COLORS)]
        framedurs = cam_df['framedur']

        # Trace of first N frames
        N = min(200, len(framedurs))
        ax1 = axes[0, j]
        ax1.plot(range(N), framedurs[:N], color=color)
        ax1.set_ylim(bottom=0.03, top=min(0.15, ax1.get_ylim()[1] + 5))
        ax1.set_xlim(0, N)
        ax1.set_title(str(camID), fontsize=16, color=color)
        ax1.set_xlabel('Frame Number', fontsize=14)
        if j == 0:
            ax1.set_ylabel('Frame Duration (secs)', fontsize=14)
        ax1.tick_params(labelsize=12)

        # Histogram of all frames
        ax2 = axes[1, j]
        bin_max = min(0.15, framedurs.max()) + 0.005
        ax2.hist(framedurs, bins=np.arange(0, bin_max, 0.005), color=color)
        ax2.set_xlabel('Frame Duration (secs)', fontsize=14)
        if j == 0:
            ax2.set_ylabel('Frequency', fontsize=14)
        ax2.tick_params(labelsize=12)

        # Row labels
        if j == (nCams - 1):
            ax1.text(1.1, 0.5, f'Trace (first {N} frames)', fontsize=14,
                     weight='bold', rotation=-90, ha='left', va='center',
                     transform=ax1.transAxes)
            ax2.text(1.1, 0.5, 'Histogram (all frames)', fontsize=14,
                     weight='bold', rotation=-90, ha='left', va='center',
                     transform=ax2.transAxes)

    # Save
    out_plotfile = out_xlfile.replace('.xlsx', '-frame_durs.png')
    fig.savefig(out_plotfile, dpi=200, bbox_inches='tight')
    plt.close(fig)


    # Multi-cam only: synchrony #
    if nCams > 1:
        # Plot
        fig, ax = plt.subplots(figsize=(12,4))

        xx = range(len(synchrony))
        h = ax.plot(xx, synchrony)
        ax.set_xlim(0, max(xx))

        ax.set_ylabel('Time Difference From Mean (secs)', fontsize=14)
        ax.set_xlabel('Frame Number', fontsize=14)
        ax.tick_params(labelsize=12)

        leg_labels = synchrony.columns
        ax.legend(h, leg_labels, fontsize=12, loc='center left',
                  bbox_to_anchor=(1.02, 0.5), bbox_transform=ax.transAxes)

        # Save
        out_plotfile = out_xlfile.replace('.xlsx', '-synchrony.png')
        fig.savefig(out_plotfile, dpi=200, bbox_inches='tight')
        plt.close(fig)